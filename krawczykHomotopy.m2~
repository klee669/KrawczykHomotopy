restart
needsPackage "NumericalAlgebraicGeometry"
--needsPackage "NumericalCertification"


-- Krawczy Test function (simplified ver for real intervals)
matrixApply = method()
matrixApply (Matrix,FunctionClosure) := (M,F) -> (matrix (apply(entries M,L->apply(L,i->F i))))
--matrixCCiApply = method()
--matrixCCiApply (Matrix,FunctionClosure) := (M,F) -> (matrixCCi (apply(entries M,L->apply(L,i->F i))))
--matrixCCiApply (CCiMatrix,FunctionClosure) := (M,F) -> (matrixCCi (apply(M,L->apply(L,i->F i))))

intervalEval = method(Options => {Strategy=>Substitution})
intervalEval (RingElement,Matrix) := o -> (f,X) -> (
	     if o.Strategy == Substitution then sub(f,X))


generalizedKrawczykOperator = (y,Y,Fy,DF',X) -> (
       y - Y*Fy+(id_((ring y)^(numrows y))-Y*DF')*(X-y))

krawczykOperator = method()
krawczykOperator (Matrix,Matrix,Matrix) := (F,X,y) -> (
	jac := transpose jacobian(F);
	jacInterval := matrixApply (jac,i->sub(i,X));
	midJac := matrixApply(jacInterval,i->midpoint i);
	Y := midJac^(-1);
	generalizedKrawczykOperator(transpose y,Y,transpose sub(F,y),jacInterval,transpose X)
)



intervalKrawczykOperator = method()
intervalKrawczykOperator (Matrix,Matrix,Matrix) := (F,X,y) -> (
	jac := transpose jacobian(F);
	jacInterval := matrixApply (jac,i->sub(i,X));
	midJac := matrixApply(jacInterval,i->midpoint i);
	Y := midJac^(-1);
	generalizedIntervalKrawczykOperator(transpose y,Y,transpose sub(F,sub(y,RRi)),jacInterval,transpose X)
)
intervalKrawczykOperatorNorm = method()
intervalKrawczykOperatorNorm (Matrix,Matrix,Matrix) := (F,X,y) -> (
	jac := transpose jacobian(F);
	jacInterval := matrixApply (jac,i->sub(i,X));
	midJac := matrixApply(jacInterval,i->midpoint i);
	Y := midJac^(-1);
	normCondition(transpose y,Y,transpose sub(F,sub(y,RRi)),jacInterval,transpose X)
)

generalizedIntervalKrawczykOperator = (y,Y,Fy,DF',X) -> (
       y - Y*Fy+(id_((ring y)^(numrows y))-Y*DF')*(X-y))

normCondition = (y,Y,Fy,DF',X) -> (
    maxNorm(id_((ring y)^(numrows y))-Y*DF')
    )

maxNorm = method()
maxNorm(Matrix) := M -> (
    max((norm \ flatten entries M)/(i -> right i))
    )
    


pointToInterval = method()
pointToInterval (Matrix, Point) := (F, rp) -> (
    jacOfI := transpose jacobian F;
    evalJac := evaluate(jacOfI, rp);
    Y := inverse evalJac;
    coords := coordinates rp;
    I := matrix{(coords)/(i -> interval i)};
    eqF := flatten entries F;
    u := (2.22*1e-16)^(-1/4); --machine precision
    evalF := transpose matrix {eqF/(i -> sub(i, I))};
    radii := (flatten entries(Y*evalF))/(i -> 
	u*max{abs(right i), abs(left i)});
--	+ ii*u*max{abs(right imaginaryPart i), abs(left imaginaryPart i)});
    matrixEntries := apply(length coords, i -> 
    	interval(coords#i - radii#i,coords#i + radii#i));
    matrix {matrixEntries}
    )


predictor = method()
predictor (Matrix, Number, Number, Point) := (H, t0, t1, p) -> (
    R := ring H;
    S := coefficientRing R;
    CS := coefficientRing S;
    n := numcols H;
    (fR, fRmap) := flattenRing R;
    fH := fRmap H;
    jacH := jacobian fH;
    jacHx := transpose evaluate(sub(sub((jacH)^{1..n}, {(gens fR)_0 => t0}),S),p);
    jacHt := transpose (jacH)^{0};
    pathDerivative := sub(jacHx^(-1)*jacHt,S);
    coords := coordinates p;
    point(matrix p + (transpose evaluate(sub(pathDerivative,S), p))*(t0-t1))
-*    tangentLine := sub(pathDerivative, R) + R_0 * sub(transpose matrix p,R);
    point{sub(sub(tangentLine, {R_0=>t0-t1}),CS)}*-
    )



corrector = method(Options => {CorrectorStrategy => "absolute"})
corrector (Matrix, Number, Point) := o -> (H, t1, p) -> (
    R := ring H;
    F := polySystem transpose sub(H, {R_0 => t1});
    p = matrix p;
    iter := 0;
    if o.CorrectorStrategy == "absolute" then (
    	while norm(evaluate(F,p)) > 1e-12 do (
	    p = newton(F, point p);
	    );
    ) else if o.CorrectorStrategy == "relative" then (
        local pNew;
	relErr := 1;
        while relErr > 1e-12 do (
	    pNew = newton(F, point p);
	    relErr = norm(2, matrix pNew - matrix p) / norm(2, pNew);
	    p = pNew;
	    iter = iter+1;
	    if iter > 10 then (
		return point p;
		break
		) 
	    );
    ) else error "strategy not supported";
    point p
    )

intervalKrawczykTest = method()
intervalKrawczykTest (Matrix,Matrix,Matrix) := (F,X,y) ->
(
	I = intervalKrawczykOperator(F,X,y);
	if intervalKrawczykOperatorNorm(F,X,y) < 1/sqrt(2) then (
	    if {true} == unique apply(flatten entries I,flatten entries X,(i,j)->isSubset(i,j)) then (
		m = max flatten entries matrixApply(I,i->diameter(i)/2);
		M = max flatten entries matrixApply(X,i->diameter(i)/2);
		if m < M then true else false
	   	)
	    else false
	    )
	else false
)



krawczykHomotopy = method(Options => {CorrectorStrategy => "absolute"})
krawczykHomotopy(Matrix,Point,Number) := o -> (H, p, R) -> (

    ----- INITIAL SET UP -----
    
    -- initial radius of the interval box
    -------
    r := .1; -- what is a good radius to start?
    dt := r*R;
    
    
    -- define rings for the polynomial system
    --------
    ringH := ring H;
    S := coefficientRing ringH;
    originaldt := dt;
    

    -- set t1 from dt
    --------
    t0 := 1;
    t1 := t0 - dt;

    -- set p1 using predictor corrector method
    -------
    p0 := p;
    p1predictor := predictor(H,t0,t1,p0);
    p1 := corrector(H,t1,p1predictor, o);

    -- define a polynomial ring with a interval coefficients
    --------
    v := first flatten entries last coefficients H;
    vRing := ring v;
    coeffRing := coefficientRing vRing;
    (fR, fRmap) := flattenRing vRing;
    v = sub(v, coefficientRing fR);
    SI := RRi[gens coeffRing];
    RI := SI[gens ringH];
    


    ----- MODIFY THE SYSTEM FOR INTERVAL ARITHMETIC -----

    -- solutionPath
    -- a path connecting p0 and p1
    -- the path is translated that p0 and p1 are located at 0.
    --------
    solutionPath := pipeBox(p0, p1, t0, t1, ringH);
    optionList := apply(length gens S, i -> fR_(i+1)=>fR_(i+1) + sub(solutionPath#i, fR));
    translatedH := sub(sub(H, fR), optionList);

    -- midt
    -- the midpoint of t0 and t1 (for tighter interval arithmetic computation)
    -- the system is translated that the midt is located at 0.
    --------
    midt := (t0+t1)/2; 
    translatedH = sub(translatedH, {fR_0=>fR_0 + midt});
    
    -- intervalH
    -- substitute the translatedH into the polynomial ring of interval coefficients
    --------
    intervalH := sub(translatedH, RI);
    
    -- inputInterval
    -- centered at 0 with the radius r
    --------
    inputInterval := matrix{apply(length gens S, i -> interval(-r, r))};
    

    -- this lines are inserted for the test. should be removed.   
    KF := transpose intervalKrawczykOperator(
	sub(intervalH,{RI_0=>interval(-dt/2,dt/2)}),inputInterval,matrix origin S); 
    intervalKrawczykTest(sub(intervalH,{RI_0=>interval(-dt/2,dt/2)}),inputInterval,matrix origin S);
    intervalKrawczykOperatorNorm(sub(intervalH,{RI_0=>interval(-dt/2,dt/2)}),inputInterval,matrix origin S);

    iter := 0;
    stringList := {};
    
    
    ----- A LOOP FOR HOMOTOPY TRACKING
    while t0 > dt do (
	print (dt, iter, toRR t0, r);
    	KF = transpose intervalKrawczykOperator(
	    sub(intervalH,{RI_0=>interval(-dt/2,dt/2)}),inputInterval,matrix origin S); -- Krawczyk operator for interval homotopy
    	if intervalKrawczykTest(sub(intervalH,{RI_0=>interval(-dt/2,dt/2)}),inputInterval,matrix origin S) then 
    	(
	    -- if Krawczyk test succeeds then increase dt and r
	    -----
	    stringList = append(stringList, "draw[color=olive] ("|toString t0|","|toString log(originaldt)|")--("|toString t1|","|toString log(dt)|");");
	    originaldt = dt;
    	    dt = 3*dt;
	    r = 3*r; -- what should be the good ratio for dt & r ?
    
            t0 = t1;
    	    t1 = t0 - dt;
    
    	    p0 = p1;
	        
            p1predictor = predictor(H,t0,t1, p0);
    	    p1 = corrector(H,t1,p1predictor, o);
	    
    	    solutionPath = pipeBox(p0, p1, t0, t1, ringH);
    	    optionList = apply(length gens S, i -> fR_(i+1)=>fR_(i+1) + sub(solutionPath#i, fR));
    	    translatedH = sub(sub(H, fR), optionList);

    	    midt = (t0+t1)/2;
    	    translatedH = sub(translatedH, {fR_0=>fR_0 + midt});
    	    
	    intervalH = sub(translatedH, RI);
    	    inputInterval = matrix{apply(length gens S, i -> interval(-r, r))};
	    
	    iter = iter + 1;
	    )
    	else (
	    -- if Krawczyk test fails then decrease dt and r
	    -----
	    dt = dt* (1/3);
	    r = 1/3* r;

    	    t1 = t0 - dt;    
    
            p1predictor = predictor(H,t0,t1, p0);
    	    p1 = corrector(H,t1,p1predictor, o);

    	    solutionPath = pipeBox(p0, p1, t0, t1, ringH);
    	    optionList = apply(length gens S, i -> fR_(i+1)=>fR_(i+1) + sub(solutionPath#i, fR));
    	    translatedH = sub(sub(H, fR), optionList);

    	    midt = (t0+t1)/2;
    	    translatedH = sub(translatedH, {fR_0=>fR_0 + midt});
    	    
	    intervalH = sub(translatedH, RI);
    	    inputInterval = matrix{apply(length gens S, i -> interval(-r, r))};
    	    )
	);
    t0 = t0 + 1/3*dt;
    stringList = append(stringList, "draw[color=olive] ("|toString t0|","|toString log(dt)|")--("|toString 0|","|toString log(dt)|");");
    t1 = 0;
    p1predictor = predictor(H,t0,t1,p0);
    p1 = corrector(H,t1,p1predictor, o);
    (p1, iter+1, stringList)
    )        
    

pipeBox = (p0, p1, t0, t1, ringH) -> (
    t := first gens ringH;
    solutionPath := flatten entries((1/(t0-t1)*matrix(p0)*(t-t1)+1/(t1-t0)*matrix(p1)*(t-t0)));
    solutionPath
    )


matrixConvertToCC = method()
matrixConvertToCC (Matrix) := M -> (
    R := ring M;
    if class coefficientRing R =!= RealField then error "matrix over an incorrect ring"; 
    CR := CC[gens R];
    entriesM := flatten entries M;    
    maxDeg := max(entriesM/(i -> first degree i));
    (m, c) := coefficients M;
    m = sub(m, {R_0 => ii});
    m * sub(c, CC)
    )


matrixConvertToRR = method()
matrixConvertToRR (Matrix, Ring) := (M, ringM) -> (
    C := ring M;
    if class C =!= ComplexField then error "matrix over an incorrect ring"; 
    R := RR[gens ringM];
    entriesM := entries M;    
    M = matrix apply(entriesM, i -> 
	apply(i, j -> 
	    (sub(realPart j,R)+first((imaginaryPart j)*(gens R)))));    
    sub(M, ringM)
    )
    
    
    
    
    

predictorCC = method()
predictorCC (Matrix, Number, Number, Point) := (H, t0, t1, p) -> (
    R := ring H;
    S := coefficientRing R;
    CS := coefficientRing S;
    n := numcols H;
    (fR, fRmap) := flattenRing R;
    fH := fRmap H;
    jacH := jacobian fH;
    jacHx := transpose evaluate(sub(sub((jacH)^{1..n}, {(gens fR)_0 => t0}),S),p);
    jacHx = matrixConvertToCC jacHx;
    invjacHx := sub(matrixConvertToRR(jacHx^(-1), CS), fR);
    jacHt := transpose (jacH)^{0};
    pathDerivative := evaluateImaginary sub(invjacHx*jacHt,S);
    coords := coordinates p;
    point evaluateImaginary(matrix p + (transpose evaluate(sub(pathDerivative,S), p))*(t0-t1))
-*    tangentLine := sub(pathDerivative, R) + R_0 * sub(transpose matrix p,R);
    point{sub(sub(tangentLine, {R_0=>t0-t1}),CS)}*-
    )


correctorCC = method(Options => {CorrectorStrategy => "absolute"})
correctorCC (Matrix, Number, Point) := o -> (H, t1, p) -> (
    R := ring H;
    coeffRing := coefficientRing R;
    C := coefficientRing coeffRing;
    Ht1 := sub(H, {R_0 => t1});
    (m, c) := coefficients Ht1;
    CR := CC[gens coeffRing];
    m = sub(m, CR);
    c = matrixConvertToCC(sub(c, C));
    F := polySystem transpose(m*c);    
    ringP := ring matrix p;
    p = matrixConvertToCC(matrix p);
    iter := 0;
    if o.CorrectorStrategy == "absolute" then (
    	while norm(evaluate(F,p)) > 1e-12 do (
	    p = newton(F, point p);
	    );
    ) else if o.CorrectorStrategy == "relative" then (
        local pNew;
	relErr := 1;
        while relErr > 1e-12 do (
	    pNew = newton(F, point p);
	    relErr = norm(2, matrix pNew - matrix p) / norm(2, pNew);
	    p = pNew;
	    iter = iter+1;
	    if iter > 10 then (
		return point matrixConvertToRR(matrix p, ringP);
		break
		) 
	    );
    ) else error "strategy not supported";
    point matrixConvertToRR(matrix p, ringP)
    )
    

intervalKrawczykOperatorCC = method()
intervalKrawczykOperatorCC (Matrix,Matrix,Matrix) := (F,X,y) -> (
    	n := numcols y;
	jac := transpose((jacobian(F))^{0..n-1});
	CIR := coefficientRing ring F;
	R := RR[gens CIR];
	jacInterval := matrixApply (jac,i->sub(sub(i,X), CIR));
	midJac := matrix apply(entries jacInterval, i -> (
		apply(i, j -> (
		    	(m, c) := coefficients j;
			if m == transpose c then (
			    return 0_R;
			    ) else (
			stringm := toString m;
			use R;
			m = value stringm;
		    	c = sub(c, coefficientRing CIR);
		    	c = matrixApply(c, k -> midpoint k);
		    	first flatten entries(m*sub(c, R))
			)
		    	)
		    )
	    	)
	    );
	Y := matrixConvertToRR((matrixConvertToCC(midJac))^(-1),R);
	Y = sub(Y, CIR);
	y = sub(y, CIR);
	Fy = evaluateImaginary sub(transpose sub(F, sub(y, ring F)), CIR);
       	evaluateImaginary sub(
	    generalizedIntervalKrawczykOperatorCC(
		transpose y,Y,Fy,jacInterval,transpose X),
	    CIR)
)

intervalKrawczykOperatorNorm = method()
intervalKrawczykOperatorNorm (Matrix,Matrix,Matrix) := (F,X,y) -> (
	jac := transpose jacobian(F);
	jacInterval := matrixApply (jac,i->sub(i,X));
	midJac := matrixApply(jacInterval,i->midpoint i);
	Y := midJac^(-1);
	normCondition(transpose y,Y,transpose sub(F,sub(y,RRi)),jacInterval,transpose X)
)

evaluateImaginary = method()
evaluateImaginary(RingElement) := e -> (
    fR := first flattenRing ring e;
    degI := last degree e;
    coeffRing := coefficientRing fR;
    gensfR := gens fR;
    if length gensfR > 1 then (
	I := last gensfR;
	gensR := delete(I, gensfR);
	R := coeffRing[gensR][I];
	e = sub(e, R);
	)
    else (
	I = first gensfR;
	);
    (m, c) := coefficients e;
    Ilist := {1, I, -1, -I};
    m = matrix{apply(flatten entries m, i -> Ilist#(first(degree(i))%4))};
    m * sub(c,fR)
    )
evaluateImaginary(Matrix) := M -> matrixApply(M, i -> evaluateImaginary i)

generalizedIntervalKrawczykOperatorCC = (y,Y,Fy,DF',X) -> (
    YFy := evaluateImaginary(Y*Fy);
    YDF' = evaluateImaginary(Y*DF');
    iYDF' = id_((ring y)^(numrows y)) - YDF';
    Xy := X-y;
    iYDF'Xy := evaluateImaginary(iYDF'*Xy);
    y-YFy+iYDF'Xy
    )

normCondition = (y,Y,Fy,DF',X) -> (
    maxNorm(id_((ring y)^(numrows y))-Y*DF')
    )

maxNorm = method()
maxNorm(Matrix) := M -> (
    max((norm \ flatten entries M)/(i -> right i))
    )
    

intervalKrawczykTestCC = method()
intervalKrawczykTestCC (Matrix,Matrix,Matrix) := (F,X,y) ->
(
	I = intervalKrawczykOperatorCC(F,X,y);
	entriesI := flatten((flatten entries I)/(i -> flatten entries last coefficients i));
	entriesI = entriesI/(i -> sub(i, RRi));
    	entriesX := flatten((flatten entries X)/(i -> flatten entries last coefficients i));
	entriesX = entriesX/(i -> sub(i, RRi));	
	
        if {true} == unique apply(entriesI,entriesX,(i,j)->isSubset(i,j)) then (
	    m = max apply(entriesI,i->diameter(i)/2);
	    M = max apply(entriesX,i->diameter(i)/2);
	    if m < M then true else false
	    )
	else false
)





krawczykHomotopyCC = method(Options => {CorrectorStrategy => "absolute"})
krawczykHomotopyCC(Matrix,Point,Number) := o -> (H, p, dt) -> (

    ----- INITIAL SET UP -----
    
    -- define rings for the polynomial system
    --------
    ringH := ring H;
    S := coefficientRing ringH;
    originaldt := dt;
    

    -- set t1 from dt
    --------
    t0 := 1;
    t1 := t0 - dt;

    -- set p1 using predictor corrector method
    -------
    p0 := p;
    p1predictor := predictorCC(H,t0,t1,p0);
    p1 := correctorCC(H,t1,p1predictor, o);
    
    -- initial radius of the interval box
    -------
    r := .4; -- what is a good radius to start?

    -- define a polynomial ring with a interval coefficients
    --------
    ringF := coefficientRing ringH;
    CS := coefficientRing ringF;
    
    (fR, fRmap) := flattenRing ringH;
    CIR := RRi[gens CS];
    SI := CIR[gens ringF];
    RI := SI[gens ringH];


    ----- MODIFY THE SYSTEM FOR INTERVAL ARITHMETIC -----

    -- solutionPath
    -- a path connecting p0 and p1
    -- the path is translated that p0 and p1 are located at 0.
    --------
    solutionPath := pipeBox(p0, p1, t0, t1, ringH);
    optionList := apply(length gens S, i -> fR_(i+1)=>fR_(i+1) + sub(solutionPath#i, fR));
    translatedH := evaluateImaginary sub(sub(H, fR), optionList);

    -- midt
    -- the midpoint of t0 and t1 (for tighter interval arithmetic computation)
    -- the system is translated that the midt is located at 0.
    --------
    midt := (t0+t1)/2; 
    translatedH = sub(translatedH, {fR_0=>fR_0 + midt});
    
    -- intervalH
    -- substitute the translatedH into the polynomial ring of interval coefficients
    --------
    intervalH := sub(translatedH, RI);
    
    -- inputInterval
    -- centered at 0 with the radius r
    --------
    inputInterval := matrix{apply(length gens S, i -> interval(-r, r)+sub(first gens CS, RI)*interval(-r,r))};
    
    F := sub(intervalH, {RI_0=> interval(-dt/2,dt/2)});
    X := sub(inputInterval,CIR);
    y := matrix origin S;
    
    

    -- this lines are inserted for the test. should be removed.   
    KF := transpose intervalKrawczykOperatorCC(F, X, y); 
    intervalKrawczykTestCC(F, X, y);
    

    iter := 0;
    
    ----- A LOOP FOR HOMOTOPY TRACKING
    while t1 > 0 do (
	print ("(dt, #paths tracked, radius, t0) = "|toString(dt, iter, r, toRR t0));
--	print coordinates p1;
	KF = transpose intervalKrawczykOperatorCC(F, X, y); 
    	if     intervalKrawczykTestCC(F, X, y) then 
    	(
	    -- if Krawczyk test succeeds then increase dt and r
	    -----
    	    dt = 3*dt;
	    r = 3*r; -- what should be the good ratio for dt & r ?

    
            t0 = t1;
    	    t1 = t0 - dt;
    
    	    p0 = p1;
	    
	    p1predictor = predictorCC(H,t0,t1,p0);
    	    p1 = correctorCC(H,t1,p1predictor, o);
	    
	    solutionPath = pipeBox(p0, p1, t0, t1, ringH);
	    optionList = apply(length gens S, i -> fR_(i+1)=>fR_(i+1) + sub(solutionPath#i, fR));
    	    translatedH = evaluateImaginary sub(sub(H, fR), optionList);
	    

    	    midt = (t0+t1)/2;
    	    translatedH = sub(translatedH, {fR_0=>fR_0 + midt});
    	    
	    intervalH = sub(translatedH, RI);
	    inputInterval = matrix{apply(length gens S, i -> interval(-r, r)+sub(first gens CS, RI)*interval(-r,r))};
	    
	    F = sub(intervalH, {RI_0=> interval(-dt/2,dt/2)});
	    X = sub(inputInterval,CIR);
    	    y = matrix origin S;

	    iter = iter + 1;
	    )
    	else (
	    -- if Krawczyk test fails then decrease dt and r
	    -----
	    dt = dt* (1/3);
	    r = 1/3* r;

    	    t1 = t0 - dt;    
    
	    p1predictor = predictorCC(H,t0,t1,p0);
    	    p1 = correctorCC(H,t1,p1predictor, o);
    	    
	    solutionPath = pipeBox(p0, p1, t0, t1, ringH);
	    optionList = apply(length gens S, i -> fR_(i+1)=>fR_(i+1) + sub(solutionPath#i, fR));
    	    translatedH = evaluateImaginary sub(sub(H, fR), optionList);


    	    midt = (t0+t1)/2;
    	    translatedH = sub(translatedH, {fR_0=>fR_0 + midt});
	        	    
	    intervalH = sub(translatedH, RI);
	    inputInterval = matrix{apply(length gens S, i -> interval(-r, r)+sub(first gens CS, RI)*interval(-r,r))};

	    F = sub(intervalH, {RI_0=> interval(-dt/2,dt/2)});
	    X = sub(inputInterval,CIR);
    	    y = matrix origin S;

    	    )
	);
    t0 = t0 + 1/3*dt;
    t1 = 0;
    p1predictor = predictorCC(H,t0,t1,p0);
    p1 = correctorCC(H,t1,p1predictor, o);
    (p1, iter+1)
    )        




krawczykHomotopyCC2 = method(Options => {CorrectorStrategy => "absolute"})
krawczykHomotopyCC2(Matrix,Point,Number) := o -> (H, p, dt) -> (

    ----- INITIAL SET UP -----
    
    -- define rings for the polynomial system
    --------
    ringH := ring H;
    S := coefficientRing ringH;
    originaldt := dt;
    

    -- set t1 from dt
    --------
    t0 := 1;
    t1 := t0 - dt;

    -- set p1 using predictor corrector method
    -------
    p0 := p;
--    p1predictor := predictorCC(H,t0,t1,p0);
--    p1 := correctorCC(H,t1,p1predictor, o);
    
    -- initial radius of the interval box
    -------
    r := .1; -- what is a good radius to start?

    -- define a polynomial ring with a interval coefficients
    --------
    ringF := coefficientRing ringH;
    CS := coefficientRing ringF;
    
    (fR, fRmap) := flattenRing ringH;
    CIR := RRi[gens CS];
    SI := CIR[gens ringF];
    RI := SI[gens ringH];


    ----- MODIFY THE SYSTEM FOR INTERVAL ARITHMETIC -----

    -- solutionPath
    -- a path connecting p0 and p1
    -- the path is translated that p0 and p1 are located at 0.
    --------
--    solutionPath := pipeBox(p0, p1, t0, t1, ringH);
--    optionList := apply(length gens S, i -> fR_(i+1)=>fR_(i+1) + sub(solutionPath#i, fR));
--    translatedH := evaluateImaginary sub(sub(H, fR), optionList);
    translatedH := sub(H, fR);

    -- midt
    -- the midpoint of t0 and t1 (for tighter interval arithmetic computation)
    -- the system is translated that the midt is located at 0.
    --------
--    midt := (t0+t1)/2; 
--    translatedH = sub(translatedH, {fR_0=>fR_0 + midt});
    
    
    -- intervalH
    -- substitute the translatedH into the polynomial ring of interval coefficients
    --------
    intervalH := sub(translatedH, RI);
    
    -- inputInterval
    -- centered at 0 with the radius r
    --------
    p0coords := coordinates p0;
    inputInterval := matrix{apply(length gens S, i -> sub(p0coords#i, RI) + interval(-r, r)+sub(first gens CS, RI)*interval(-r,r))};
    

--    F := sub(intervalH, {RI_0=> interval(-dt/2,dt/2)});
    F := sub(intervalH, {RI_0=> interval(t1,t0)});
    X := sub(inputInterval,CIR);
    y := matrix p0;--matrix origin S;
    
    

    -- this lines are inserted for the test. should be removed.   
    KF := transpose intervalKrawczykOperatorCC(F, X, y); 
    intervalKrawczykTestCC(F, X, y);
    

    iter := 0;
    
    ----- A LOOP FOR HOMOTOPY TRACKING
    while t1 > 0 do (
	print ("(dt, #paths tracked, radius, t0) = "|toString(dt, iter, r, toRR t0));
--	print coordinates p1;
	KF = transpose intervalKrawczykOperatorCC(F, X, y); 
    	if     intervalKrawczykTestCC(F, X, y) then 
    	(
	    -- if Krawczyk test succeeds then increase dt and r
	    -----
    	    dt = 3*dt;
	    r = 3*r; -- what should be the good ratio for dt & r ?

    	    p0 = correctorCC(H,t1,p0, o);
    
            t0 = t1;
    	    t1 = t0 - dt;
    
	    
--	    p1predictor = predictorCC(H,t0,t1,p0);

    translatedH = sub(H, fR);

--    	    midt = (t0+t1)/2;
--    	    translatedH = sub(translatedH, {fR_0=>fR_0 + midt});
    	    
    
    -- inputInterval
    -- centered at 0 with the radius r
    --------
    p0coords = coordinates p0;
    inputInterval = matrix{apply(length gens S, i -> sub(p0coords#i, RI) + interval(-r, r)+sub(first gens CS, RI)*interval(-r,r))};
    
--    F = sub(intervalH, {RI_0=> interval(-dt/2,dt/2)});
    F = sub(intervalH, {RI_0=> interval(t1,t0)});
    X = sub(inputInterval,CIR);
    y = matrix p0;--matrix origin S;

	    iter = iter + 1;
	    )
    	else (
	    -- if Krawczyk test fails then decrease dt and r
	    -----
	    dt = dt* (1/3);
	    r = 1/3* r;

    	    t1 = t0 - dt;    
    
--	    p1predictor = predictorCC(H,t0,t1,p0);
--    	    p1 = correctorCC(H,t1,p1predictor, o);
    	    
--	    solutionPath = pipeBox(p0, p1, t0, t1, ringH);
--	    optionList = apply(length gens S, i -> fR_(i+1)=>fR_(i+1) + sub(solutionPath#i, fR));
--    	    translatedH = evaluateImaginary sub(sub(H, fR), optionList);

    translatedH = sub(H, fR);

--    	    midt = (t0+t1)/2;
--    	    translatedH = sub(translatedH, {fR_0=>fR_0 + midt});

    
    -- inputInterval
    -- centered at 0 with the radius r
    --------
    p0coords = coordinates p0;
    inputInterval = matrix{apply(length gens S, i -> sub(p0coords#i, RI) + interval(-r, r)+sub(first gens CS, RI)*interval(-r,r))};
    
--    F = sub(intervalH, {RI_0=> interval(-dt/2,dt/2)});

    F = sub(intervalH, {RI_0=> interval(t1,t0)});
    X = sub(inputInterval,CIR);
    y = matrix p0;--matrix origin S;

    	    )
	);
    t0 = t0 + 1/3*dt;
    t1 = 0;
--    p1predictor = predictorCC(H,t0,t1,p0);
    p0 = correctorCC(H,t1,p0, o);
    (p0, iter+1)
    )        


    


-- initial 5pt data from monodromy solver
p1 = matrix {{8, 2/5, 8/3, 4/7, 1/2, 1/3, 1, 6/5, 7/8, 6, 7/3, 2/9, 5/4, 5/6, 5, 10/7, 1, 4/3, 2/3, 5/3, 5/4, 1/10, 2/3, 4/5, 7/6, 7/5, 9/7, 3/2, 9/7, 5}}
L = {{toCC(.63711024621949652p53,.12057031795123934p53e1),toCC(.19382050116397848p53,-.11225908742974033p53e1),toCC(-.26204092227479425p53,.17563599945152017p53)},{toCC(.30911602590079741p53e1,.3556413999176124p53e-159),toCC(-.32833365162094035p53e1,-.71128279983522479p53e-159),toCC(.29558982203977191p53e1,.5334620998764186p53e-159)},{toCC(-.83351688659631638p53e1,.2581421227157166p53e-148),toCC(-.4555067412962571p53e1,.15351055226585514p53e-148),toCC(.29830783577918458p53e1,-.80955813632739524p53e-149)},{toCC(-.62591034513017907p53,-.11491825479445164p53e1),toCC(-.22383468156330774p53,.120952684184228p53e1),toCC(.16539071912642797p53e-1,-.3899162625400876p53)},{toCC(-.45707195427403197p53,.52901658237744844p53e-159),toCC(-.78727734883678457p53e-1,-.16003862996292558p53e-159),toCC(-.2948506089296245p53,.10669241997528372p53e-159)},{toCC(-.36895167315534505p53,-.35280139032287057p53e-1),toCC(-.26160147368570608p53,.4420910148614689p53),toCC(-.1888799867476218p53,.48399729226514099p53)},{toCC(-.62591034513017874p53,.11491825479445152p53e1),toCC(-.22383468156330824p53,-.12095268418422795p53e1),toCC(.1653907191264346p53e-1,.3899162625400876p53)},{toCC(-.93254348788131995p53e1,.25669306976362095p53e-168),toCC(.27678837455129188p53e1,-.79699057950801666p53e-169),toCC(-.20206817495665557p53e1,.51235108682658214p53e-169)},{toCC(-.36895167315534516p53,.35280139032287168p53e-1),toCC(-.26160147368570597p53,-.44209101486147045p53),toCC(-.18887998674762166p53,-.48399729226514254p53)},{toCC(.22213973356527603p53,-.44177771228989421p53),toCC(.35035008006830133p53e-1,.56747447590367088p53e-1),toCC(.1002692450077632p53,-.7141429628379522p53)},{toCC(-.32264398831002805p53,-.46918234694023736p53),toCC(-.22006285769117259p53,.20104504593422383p53e-1),toCC(.16046563554524232p53,-.69163025907649189p53)},{toCC(.38273554332620305p53e1,.51432720418187383p53),toCC(.21750379287374133p53e1,.48823225323311537p53),toCC(-.1737608516752694p53e1,-.17574486786751893p53e1)},{toCC(.63711024621949464p53,-.12057031795123898p53e1),toCC(.19382050116397434p53,.11225908742974005p53e1),toCC(-.26204092227479259p53,-.17563599945152203p53)},{toCC(.83027904412149756p53,.34960972177500969p53e-155),toCC(-.28512782319067198p53e1,-.25638046263500711p53e-154),toCC(.28657814698067927p53e1,.34960972177500969p53e-154)},{toCC(.38273554332620314p53e1,-.5143272041818735p53),toCC(.21750379287374142p53e1,-.48823225323311531p53),toCC(-.17376085167526945p53e1,.17574486786751897p53e1)},{toCC(.22213973356527564p53,.44177771228989343p53),toCC(.3503500800682996p53e-1,-.56747447590367248p53e-1),toCC(.10026924500776389p53,.71414296283795153p53)},{toCC(-.23160441865407853p53e-1,.15737305599381652p53e-163),toCC(-.18143606320856737p53,.30389279778116294p53e-163),toCC(.35324081208169639p53,.15194639889058147p53e-163)},{toCC(-.32264398831002516p53,.46918234694023758p53),toCC(-.22006285769117223p53,-.20104504593423184p53e-1),toCC(.16046563554524299p53,.69163025907649034p53)},{toCC(-.21102036473718p53,.54266571032350524p53e-165),toCC(-.48695501016240941p53e-1,-.27133285516175262p53e-165),toCC(-.17171969854784189p53,-.6104989241139434p53e-165)},{toCC(-.47927010698882466p53,.20143751167208515p53e-161),toCC(.57589178521187092p53e1,.51401296081842417p53e-161),toCC(.71193107323117095p53e1,.69982170003319236p53e-161)}}

end--


-- CC examples
restart
load("krawczykHomotopy.m2")

C = RR[i]
S = C[x]
R = S[t]
m = 10;
F = x^2-1+m;
v = 10;
H = matrix{{F+v*t}}
dt = 1/30
p = point{{4.358898943*i}}


krawczykHomotopyCC(H,p,dt)
krawczykHomotopyCC(H,p,dt, CorrectorStrategy => "relative")
krawczykHomotopyCC2(H,p,dt, CorrectorStrategy => "relative")

restart
load("krawczykHomotopy.m2")


C = RR[i]
S = C[x]
R = S[t]
m = 39;
F = x^2-1+m;
v = 39;
H = matrix{{F+ v*t}};
dt = 1/30;
p = point{{8.77496*i}}

krawczykHomotopyCC(H,p,dt,CorrectorStrategy => "relative")


restart
load("krawczykHomotopy.m2")


C = RR[i]
S = C[x]
R = S[t]
m = 100;
F = x^2-1-m;
v = 100;
H = matrix{{F+ v*t}};
dt = .02;
p = point{{1}}

krawczykHomotopyCC(H,p,dt,CorrectorStrategy => "relative")
krawczykHomotopyCC2(H,p,dt,CorrectorStrategy => "relative")



restart
load("krawczykHomotopy.m2")


C = RR[i]
S = C[x]
R = S[t]
m = 100;
F = x^2-1+m;
v = 100;
H = matrix{{F+ v*t}};
dt = 1/30;
p = point{{14.107*i}}

krawczykHomotopyCC(H,p,dt,CorrectorStrategy => "relative")



restart
load("krawczykHomotopy.m2")


C = RR[i]
S = C[x]
R = S[t]
m = 2000;
F = x^2-1+m;
v = 2000;
H = matrix{{F+ v*t}};
dt = 1/30;
p = point{{63.237647015049*i}}
o = CorrectorStrategy => "relative"


krawczykHomotopyCC(H,p,dt,CorrectorStrategy => "relative")



--parameter homotopy examples CC
restart
load("krawczykHomotopy.m2")

C = RR[i]
S = C[x,y]
R = S[t]
P = R[a,b] -- parameters
F = matrix{{x^3+y+x^2-a,x*y-a+b}}; 
startParameter = matrix{{1_R,0}}
targetParameter = matrix{{2_R,5}}
paramHomotopy = startParameter*t + (1-t)*targetParameter; -- parameter homotopy
H = sub(F,paramHomotopy)

dt = 1/20;
p = point matrix {{-.864054*i-1.06612, .458821*i-.566121}}

krawczykHomotopyCC(H,p,dt)
krawczykHomotopyCC(H,p,dt,CorrectorStrategy => "relative")
krawczykHomotopyCC2(H,p,dt,CorrectorStrategy => "relative")



-- random degree 3 example 
restart
load("krawczykHomotopy.m2")

C = RR[i]
R = RR[x_1 .. x_3]
K = {random(2,R)-1, random(2,R)+ random(1,R) -1, random(2, R) + random(2, R)-1}
sols = solveSystem K
T = {x_1^2- 1, x_2^2-1, x_3^2-1}
xs = solveSystem T


R = C[gens R]
K = K/(i -> sub(i, R))
T = T/(i -> sub(i, R))
S = R[t]
H = matrix{(random(RR)+random(1,C))*t * T + (1-t) * K}
dt = .4


k = 1;
elapsedTime results = apply(xs, p -> (
	print(k);
	sol = point matrixConvertToRR(matrix p, C);
	k = k + 1;
    	krawczykHomotopyCC(H, sol,dt, CorrectorStrategy => "relative")
	)
    )
-- 517.868 seconds.
	
averageIter = toRR sum(results/(i -> last i))/(#results)
-- 317.75 iters/path
maxIter = toRR max(results/(i -> last i))
-- 509
minIter = toRR min(results/(i -> last i))
-- 203



-- random degree 4 example 
restart
load("krawczykHomotopy.m2")

C = RR[i]
R = RR[x_1 .. x_4]
K = {random(2,R)-1, random(2,R)+ random(1,R) -1, random(2, R) + random(1, R)-1,random(2, R) + random(1, R)-1}
sols = solveSystem K
T = {x_1^2- 1, x_2^2-1, x_3^2-1, x_4^2-1}
xs = solveSystem T


R = C[gens R]
K = K/(i -> sub(i, R))
T = T/(i -> sub(i, R))
S = R[t]
H = matrix{(random(RR)+random(1,C))*t * T + (1-t) * K}
dt = .10
dt = .8

k = 1;
elapsedTime results = apply(xs, p -> (
	print(k);
	sol = point matrixConvertToRR(matrix p, C);
	k = k + 1;
    	krawczykHomotopyCC(H, sol,dt, CorrectorStrategy => "relative")
	)
    )
-- 5962.35 seconds.
	
averageIter = toRR sum(results/(i -> last i))/(#results)
-- 563.25 iters/path
maxIter = max(results/(i -> last i))
-- 1257
minIter = min(results/(i -> last i))
-- 211





-- katsura
restart
needsPackage "ExampleSystems"
load("krawczykHomotopy.m2")
K = katsura(3,QQ)
R = ring first K
K = K/(i -> sub(i, R))
sols = solveSystem K
S = R[t]
K = K/(i -> sub(i, S))
T = {R_0- 1, R_1^2 - 1, R_2^2 - 1}
xs = solveSystem T

C = RR[i]

R = C[gens R]
K = K/(i -> sub(i, R))
T = T/(i -> sub(i, R))
S = R[t]
H = matrix{(random(RR)+random(1,C))*t * T + (1-t) * K}
dt = .003



elapsedTime results = apply(xs, p -> (
	sol = point matrixConvertToRR(matrix p, C);
    	krawczykHomotopyCC2(H, sol,dt, CorrectorStrategy => "relative")
	)
    )
-- 150 seconds.
	
averageIter = toRR sum(results/(i -> last i))/(#results)
-- 264.25 iters/path
maxIter = toRR max(results/(i -> last i))
-- 289
miIter = toRR min(results/(i -> last i))
-- 239


-- katsura
restart
needsPackage "ExampleSystems"
load("krawczykHomotopy.m2")
K = katsura(4,QQ)
R = ring first K
K = K/(i -> sub(i, R))
sols = solveSystem K
S = R[t]
K = K/(i -> sub(i, S))
T = {R_0- 1, R_1^2 - 1, R_2^2-1, R_3^2 - 1}
xs = solveSystem T

C = RR[i]

R = C[gens R]
K = K/(i -> sub(i, R))
T = T/(i -> sub(i, R))
S = R[t]
H = matrix{(random(RR)+random(1,C))*t * T + (1-t) * K}
dt = .10



elapsedTime results = apply(xs, p -> (
	sol = point matrixConvertToRR(matrix p, C);
    	krawczykHomotopyCC(H, sol,dt, CorrectorStrategy => "relative")
	)
    )
-- 1505.87 secs
	
averageIter = toRR sum(results/(i -> last i))/(#results)
-- 331.75 iters/path
maxIter = max(results/(i -> last i))
-- 451
minIter = min(results/(i -> last i))
-- 233




-- katsura 5
restart
needsPackage "ExampleSystems"
load("krawczykHomotopy.m2")
K = katsura(5,QQ)
R = ring first K
K = K/(i -> sub(i, R))
sols = solveSystem K
S = R[t]
K = K/(i -> sub(i, S))
T = {R_0- 1, R_1^2 - 1, R_2^2 - 1, R_3^2 -1 , R_4^2-1}
xs = solveSystem T
p = xs#0


C = RR[i]

R = C[gens R]
K = K/(i -> sub(i, R))
T = T/(i -> sub(i, R))
S = R[t]
H = matrix{(random(RR)+random(1,C))*t * T + (1-t) * K}
dt = .10



elapsedTime results = apply(xs, p -> (
	sol = point matrixConvertToRR(matrix p, C);
    	krawczykHomotopyCC(H, sol,dt, CorrectorStrategy => "relative")
	)
    )
-- 6788.17 secs.
	
averageIter = toRR sum(results/(i -> last i))/(#results)
-- 444.75 iters/path
maxIter = max(results/(i -> last i))
-- 731
minIter = min(results/(i -> last i))
-- 311





-- specified example
restart
load("krawczykHomotopy.m2")

RNG = RR[t_1..t_2, r_(1,1)..r_(3,3)]
R = genericMatrix(RNG, r_(1,1), 3, 3)
tx = matrix{{0,-1,t_2},{1,0,-t_1},{-t_2,t_1,0}}
E = tx * R
SO3 = flatten entries(R*transpose R-id_(RNG^3)) | {det R - 1}

xs = {matrix {{3}, {3/5}, {3/2}}, matrix {{2/9}, {1/9}, {2}}, matrix {{3/10}, {1}, {1/4}}, matrix {{3/7}, {7/3}, {8/5}}, matrix {{1/4}, {3/7}, {1}}};
ys = {matrix {{-7342394/4728085}, {10004964/4728085}, {29090441/9456170}}, matrix {{-2016371/2836851}, {18421690/8510553}, {2884411/8510553}}, matrix {{1834231/9456170}, {17398814/4728085},
      {22721833/18912340}}, matrix {{-52455964/33096595}, {59693018/14184255}, {3714061/4728085}}, matrix {{-348749/3782468}, {18997758/6619319}, {765250/945617}}};
generate5ptSystem = (imagePts1, imagePts2) -> (
    {SO3#0,SO3#1,SO3#2,SO3#4,SO3#5,SO3#8} | apply(5, i -> (transpose imagePts2#i * E * imagePts1#i)_(0,0))
    )

K = {r_(1,1)^2+r_(2,1)^2+r_(3,1)^2-1, r_(1,1)*r_(1,2)+r_(2,1)*r_(2,2)+r_(3,1)*r_(3,2), r_(1,1)*r_(1,3)+r_(2,1)*r_(2,3)+r_(3,1)*r_(3,3), r_(1,2)^2+r_(2,2)^2+r_(3,2)^2-1,
      r_(1,2)*r_(1,3)+r_(2,2)*r_(2,3)+r_(3,2)*r_(3,3), r_(1,3)^2+r_(2,3)^2+r_(3,3)^2-1,
      -9.22903*t_2*r_(1,1)+9.22903*t_1*r_(1,2)-6.34821*t_1*r_(1,3)-4.6588*t_2*r_(1,3)-1.84581*t_2*r_(2,1)+1.84581*t_1*r_(2,2)-1.26964*t_1*r_(2,3)-.931759*t_2*r_(2,3)-4.61452*t_2*r_(3,1)+4.61452*t_1*r_(
      3,2)-3.17411*t_1*r_(3,3)-2.3294*t_2*r_(3,3)+6.34821*r_(1,1)+4.6588*r_(1,2)+1.26964*r_(2,1)+.931759*r_(2,2)+3.17411*r_(3,1)+2.3294*r_(3,2),
      -.0753159*t_2*r_(1,1)+.0753159*t_1*r_(1,2)-.481016*t_1*r_(1,3)-.157951*t_2*r_(1,3)-.037658*t_2*r_(2,1)+.037658*t_1*r_(2,2)-.240508*t_1*r_(2,3)-.0789753*t_2*r_(2,3)-.677843*t_2*r_(3,1)+.677843*t_1
      *r_(3,2)-4.32914*t_1*r_(3,3)-1.42156*t_2*r_(3,3)+.481016*r_(1,1)+.157951*r_(1,2)+.240508*r_(2,1)+.0789753*r_(2,2)+4.32914*r_(3,1)+1.42156*r_(3,2),
      -.360429*t_2*r_(1,1)+.360429*t_1*r_(1,2)-1.10397*t_1*r_(1,3)+.0581916*t_2*r_(1,3)-1.20143*t_2*r_(2,1)+1.20143*t_1*r_(2,2)-3.67989*t_1*r_(2,3)+.193972*t_2*r_(2,3)-.300357*t_2*r_(3,1)+.300357*t_1*r
      _(3,2)-.919972*t_1*r_(3,3)+.048493*t_2*r_(3,3)+1.10397*r_(1,1)-.0581916*r_(1,2)+3.67989*r_(2,1)-.193972*r_(2,2)+.919972*r_(3,1)-.048493*r_(3,2),
      -.336656*t_2*r_(1,1)+.336656*t_1*r_(1,2)-1.8036*t_1*r_(1,3)-.679258*t_2*r_(1,3)-1.83291*t_2*r_(2,1)+1.83291*t_1*r_(2,2)-9.8196*t_1*r_(2,3)-3.69818*t_2*r_(2,3)-1.25685*t_2*r_(3,1)+1.25685*t_1*r_(3
      ,2)-6.73344*t_1*r_(3,3)-2.5359*t_2*r_(3,3)+1.8036*r_(1,1)+.679258*r_(1,2)+9.8196*r_(2,1)+3.69818*r_(2,2)+6.73344*r_(3,1)+2.5359*r_(3,2),
      -.202315*t_2*r_(1,1)+.202315*t_1*r_(1,2)-.717512*t_1*r_(1,3)-.0230504*t_2*r_(1,3)-.346826*t_2*r_(2,1)+.346826*t_1*r_(2,2)-1.23002*t_1*r_(2,3)-.0395149*t_2*r_(2,3)-.80926*t_2*r_(3,1)+.80926*t_1*r
      _(3,2)-2.87005*t_1*r_(3,3)-.0922014*t_2*r_(3,3)+.717512*r_(1,1)+.0230504*r_(1,2)+1.23002*r_(2,1)+.0395149*r_(2,2)+2.87005*r_(3,1)+.0922014*r_(3,2)}

sols = solveSystem K



-- new problem instance
Xs = apply(xs, x -> x + (1/100) * (random(QQ^2, QQ^1) || matrix{{0}}))
Ys = apply(ys, x -> x + (1/100) * (random(QQ^2, QQ^1) || matrix{{0}}))
G = generate5ptSystem(Xs, Ys)
xs = solveSystem G

S = RNG[T]
K = K/(i -> sub(i, S))


C = RR[i]

R = C[gens RNG]
S = R[T]
K = K/(i -> sub(i, R))
G = G/(i -> sub(i, R))
H = matrix{(random(RR)+random(1,C))*T * G + (1-T) * K}
dt = .10


p = point matrixConvertToRR(matrix first xs, C);
o = CorrectorStrategy => "relative"
elapsedTime krawczykHomotopyCC(H, p, dt, o)  -- too slow & makes the machine slow as it goes.

elapsedTime results = apply(xs, p -> (
	sol = point matrixConvertToRR(matrix p, C);
    	krawczykHomotopyCC(H, sol,dt, CorrectorStrategy => "relative")
	)
    )
-- 6788.17 secs.
	
averageIter = toRR sum(results/(i -> last i))/(#results)
-- 411.25 iters/path
-- changing the radius doesn't really change #iters... Why?






---- reduced example
--------------------

restart
load("krawczykHomotopy.m2")


symbolicInverse = M -> (
    n := numcols M;
    R := ring M;
    cofactor := reshape(R^n,R^n, M);
    entryTable := table(subsets(3,1),subsets(3,1), (i,j) -> flatten {i,j});
    cofactor = matrix applyTable(entryTable, i -> 
	(-1)^(3-i#0+3-i#1)*(det(submatrix'(cofactor,{i#0},{i#1}))));
    transpose cofactor
    )


RNG = QQ[x,y,z]
A = matrix{{0,x,y},{-x,0,z},{-y,-z,0}}
detSI = det symbolicInverse(id_(RNG^3)-A)
R = (id_(RNG^3)+A)*symbolicInverse(id_(RNG^3)-A)


generate5ptData = () -> (
    worldPts := apply(5, i -> random(QQ^3, QQ^1) || matrix{{1}});
    R0 := random(QQ^3, QQ^3); R0 = R0 - transpose R0; R0 = (id_(QQ^3) - R0) * (id_(QQ^3) + R0)^(-1);
    t0 := random(QQ^2, QQ^1) || matrix{{1}};
    imagePts1 := apply(worldPts, pt -> pt^{0,1,2});
    worldPts = apply(5, i -> random(QQ^3, QQ^1) || matrix{{1}});
    imagePts2 := apply(worldPts, pt -> matrix{{0,-pt_(2,0),pt_(1,0)},{pt_(2,0),0,-pt_(0,0)},{-pt_(1,0),pt_(0,0),0}});
    (imagePts1, imagePts2)    
    )

generate5ptSystem = (imagePts1, imagePts2,R) -> (
    eqList := apply(5, i -> imagePts2#i * R * imagePts1#i);
    {1*det(eqList#0|eqList#1|eqList#2),1*det(eqList#0|eqList#1|eqList#3),1*det(eqList#0|eqList#1|eqList#4)}
    )

(xs, ys) = generate5ptData();
F = generate5ptSystem(xs, ys,R);
F= F/(i -> product apply(2, j -> (toList factor i)#(j+1)#0));
initialSols = solveSystem F;
Fall = polySystem(F)

-- new problem instance
Xs = apply(xs, x -> x + (1/100) * (random(QQ^2, QQ^1) || matrix{{0}}))
Ys = apply(ys, x -> x + (1/100) * (random(QQ^3, QQ^3)))
(Xs, Ys) = generate5ptData();
G = generate5ptSystem(Xs, Ys,R)
G= G/(i -> product apply(2, j -> (toList factor i)#(j+1)#0));
sols = solveSystem G

C = RR[i]
RNG = C[x,y,z]
F = F/(i -> 1/1000* sub(i, RNG))
G = G/(i -> 1/1000*sub(i, RNG))

S = RNG[T]
H = matrix{(3*C_0)*(T) * F + (1-T) * G}
p = first initialSols
p = newton(polySystem F, p)
p = point matrixConvertToRR(matrix p, C)
dt = 1/480
dt = .1


krawczykHomotopyCC(H,p,dt, CorrectorStrategy => "relative") 
-- the target system has multiple roots so might not be feasible


-- Schubert example from "Robust" Beltran-Leykin paper
restart
load "krawczykHomotopy.m2"
load "schubert-setup.m2"
Rt = R[t]
chartCoeff = random(QQ^1, QQ^7)
chart = matrix{{(chartCoeff * transpose vars R)_(0,0) - 1}}
H = matrix{(1+i) * t * S + (1-t) * T} | chart
xs = hsols/(x -> (mx := matrix(C, {x}); denom := chartCoeff * transpose mx ;  matrixConvertToCC mx))
-*
If I plug in any of "hsols" to H, expect first six equations to vanish
If I plug in any of "xs" to H, expect all seven equations to vanish
*-
xs = xs/(x -> 1/(norm(2,x))*x)
p = correctorCC(H, 1,point matrixConvertToRR(first xs, C))

sub(matrix{S}, matrix{first hsols})
evaluateImaginary(sub(H, matrix{first hsols} | matrix{{1.0}}))
evaluateImaginary(sub(S, first xs | matrix{{1.0}}))

dt = .85
krawczykHomotopyCC(H, p, dt, CorrectorStrategy=>"relative")
--o11 = ({- .0989094i + .128088, .0513266i + .0159626, .0600775i + .182523, - .0550872i + .0612029, .0196133i + .306229, - .0151061i + .201311, - .0208232i + .235741}, 2571)
